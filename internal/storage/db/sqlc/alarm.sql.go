// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: alarm.sql

package sqlc

import (
	"context"
)

const alarmCountActive = `-- name: AlarmCountActive :one
SELECT COUNT(*)
FROM alarms
WHERE deactivated_at IS NULL
`

func (q *Queries) AlarmCountActive(ctx context.Context, db DBTX) (int64, error) {
	row := db.QueryRowContext(ctx, alarmCountActive)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const alarmCountDeactive = `-- name: AlarmCountDeactive :one
SELECT COUNT(*)
FROM alarms
WHERE deactivated_at IS NOT NULL
`

func (q *Queries) AlarmCountDeactive(ctx context.Context, db DBTX) (int64, error) {
	row := db.QueryRowContext(ctx, alarmCountDeactive)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const alarmCreate = `-- name: AlarmCreate :one
INSERT INTO alarms (
	type,
	data,
	activated_at
)
VALUES (
	?1,
	?2,
	?3
)
RETURNING id, type, data, activated_at, deactivated_at
`

type AlarmCreateParams struct {
	Type        string `json:"type"`
	Data        string `json:"data"`
	ActivatedAt string `json:"activated_at"`
}

func (q *Queries) AlarmCreate(ctx context.Context, db DBTX, arg AlarmCreateParams) (Alarm, error) {
	row := db.QueryRowContext(ctx, alarmCreate, arg.Type, arg.Data, arg.ActivatedAt)
	var i Alarm
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Data,
		&i.ActivatedAt,
		&i.DeactivatedAt,
	)
	return i, err
}

const alarmDeactivate = `-- name: AlarmDeactivate :exec
UPDATE alarms
SET deactivated_at = ?1
WHERE id = ?2
`

type AlarmDeactivateParams struct {
	DeactivatedAt *string `json:"deactivated_at"`
	ID            int64   `json:"id"`
}

func (q *Queries) AlarmDeactivate(ctx context.Context, db DBTX, arg AlarmDeactivateParams) error {
	_, err := db.ExecContext(ctx, alarmDeactivate, arg.DeactivatedAt, arg.ID)
	return err
}

const alarmDeactivateAllActivated = `-- name: AlarmDeactivateAllActivated :exec
UPDATE alarms
SET deactivated_at = ?1
WHERE deactivated_at IS NULL
`

func (q *Queries) AlarmDeactivateAllActivated(ctx context.Context, db DBTX, deactivatedAt *string) error {
	_, err := db.ExecContext(ctx, alarmDeactivateAllActivated, deactivatedAt)
	return err
}

const alarmDeleteDeactivated = `-- name: AlarmDeleteDeactivated :exec
DELETE FROM alarms
WHERE deactivated_at IS NOT NULL
`

func (q *Queries) AlarmDeleteDeactivated(ctx context.Context, db DBTX) error {
	_, err := db.ExecContext(ctx, alarmDeleteDeactivated)
	return err
}

const alarmDeleteDeactivatedByThreshold = `-- name: AlarmDeleteDeactivatedByThreshold :exec
DELETE FROM alarms
WHERE deactivated_at < ?1
`

func (q *Queries) AlarmDeleteDeactivatedByThreshold(ctx context.Context, db DBTX, threshold *string) error {
	_, err := db.ExecContext(ctx, alarmDeleteDeactivatedByThreshold, threshold)
	return err
}

const alarmListActive = `-- name: AlarmListActive :many
SELECT
	id, type, data, activated_at, deactivated_at
FROM alarms
WHERE deactivated_at IS NULL
ORDER BY activated_at DESC
LIMIT ?2
OFFSET ?1
`

type AlarmListActiveParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

func (q *Queries) AlarmListActive(ctx context.Context, db DBTX, arg AlarmListActiveParams) ([]Alarm, error) {
	rows, err := db.QueryContext(ctx, alarmListActive, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Alarm{}
	for rows.Next() {
		var i Alarm
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Data,
			&i.ActivatedAt,
			&i.DeactivatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const alarmListDeactive = `-- name: AlarmListDeactive :many
SELECT
	id, type, data, activated_at, deactivated_at
FROM alarms
WHERE deactivated_at IS NOT NULL
ORDER BY deactivated_at DESC
LIMIT ?2
OFFSET ?1
`

type AlarmListDeactiveParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

func (q *Queries) AlarmListDeactive(ctx context.Context, db DBTX, arg AlarmListDeactiveParams) ([]Alarm, error) {
	rows, err := db.QueryContext(ctx, alarmListDeactive, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Alarm{}
	for rows.Next() {
		var i Alarm
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Data,
			&i.ActivatedAt,
			&i.DeactivatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
